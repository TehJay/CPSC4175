## HW 8 - Jay Patel ##

### 1. ###
If I was more inclined to label Unified process as ‘specific series of steps’, then I would view this following chapter as something that tries put forth its own point of view in a subjective manner; On the other hand, I do view the SWE process as an adaptive methodology, so it makes me very accepting of the book’s viewpoint.
### 2. ###
This statement is very true from what I know so far. Our class iterative discussion includes 4 core topics whereas the book’s iterative process includes 5 topics. The overall concept between the two processes isn’t different, however, I did note that book fails to address the post-production area of the process. In other words, the books says that there is an iterative process only upto the production, however, the process we discussed in class mentioned that SWD cycle continues onto the next SWD iteration after production. 
### 3. ###
A. Requirements Workflow: The aim of the requirements workflow is for
the development organization to determine the client’s needs. Address the domain, the specific environment in which the target software product is to operate

B. Analysis Workflow: The aim of the analysis workflow is to analyze and refine the requirements to achieve the detailed understanding of the requirements essential for developing a software product
correctly and maintaining it easily.

C. Design Workflow: refine the artifacts of the analysis workflow until the material is in a form that can be implemented by the programmers.

D. Implementation Workflow: implement the target software product
in the chosen implementation language(s)

E. Test Workflow: testing is carried out in parallel with the other workflows, starting from the beginning.The nature of the test workflow changes depending on the artifacts being tested (requirements, analysis, design, implementation)

### 4. ###
The software Life cycle is any process model that has specification, development, validation and maintenance phases and these can repeat in cycles so it's sort of the structure of the development processes. Software project management considers the practical limits, risks and deadlines and forms a complete plan for the entire project and the maintenance of its progress. No, because project management mostly deals with the people-management side of the SWD cycle rather than the project itself.
### 5. ###
The book mentions two points about ‘testing workflow’:
1.  Every dev is responsible for his or her work to be tested. 
2.  Once tested, the artifact needs to be handed over to SQA group for independent testing.   
Requirements Artifact: Requirements need to implement traceability; everything done in the future should be able to be traced back to the Requirements Stage Book states that Analysis artifact review must be done in conjunction with client’s team and also members of the SQA group
Members of the Design team and the SQA group work through the design as a whole as well as through each separate design artifact, ensuring that the design is correct.
Each component should be tested while it is being implemented (desk checking); and after it has been implemented, it is run against test cases. This informal testing is done by the programmer. Thereafter, SQA group tests the component methodically;
Overall, I could not find any discrepancy in the book’s description of testing workflow.

### 6. ###
There are many ways of doing post delivery maintenance; I would fit the post-delivery maintenance just prior to the ending of the iterative cycle, It makes sense to have it like this as all the product changes have taken place, bug have been fix, and etc prior to this point. Additionally, the team can push out the software to ‘beta’ users for any testing with client’s side. 
### 7. ###
There is a serious difference between the book’s definition of SWD phases and the class’s. Yes, whether it’s the model from the book or from class, any two modeled approaches are mutually exclusive, meaning that the team cannot be working on phase X while also completing phase Y, it would be disastrous for the completion of project as it creates lot of confusion within the team.
### 8. ###
Both methods noted in figure 3.2 would essentially lead to the same end product, however, the main difference lies in the process itself. Using the two-dimensional process, there would more conservative notion of switching between the phases as it lays out all the phases for each workflow, meaning that the SWD team would know when a phase has been completed, and where to go back to. On the other hand, one dimensional model, the team really just moves between the workflows when they find satisfaction with the current phase, and if problems arise then it would be really difficult to point where, within each workflow the issue was. All in all, in the end, they both produce the same output, however, if team X finds organization more essential than they would find the 2D model more useful.
###9.###
The inherent difference between SW improvement & SW process improvement is in the wording. Software Improvement is more technical  (how the can the coding be improved, orr overall UExp of the project), Software process improvement is finding ways to improve ‘how we make software’. This topic is extremely important to how we make software. Even though improving the SWP & not improving the SWP would lead to the same output, I believe that if we follow an improved version of the SWP then we can build something clean, traceable, and adaptive to future condition. Personally, I would rather put in extra time to go through the improved SWP in order to have a organized working product, than just go through a simple SWP which produces the same working product, which can be susceptible to errors, and reduced usability.