## Homework 9 - Jay Patel ##

### 1. ###
Changing requirements reiterates the needs for the SWD process to be adaptable and flexible and that’s why book notes that ‘SWD process is considerably different in practice’. No how sharp and concise a process is, in the real world it will need to be flexible since all of the factors surrounding a project cannot be accounted for
### 2. ###
The life-cycle model can also be viewed as the linear model with feedback loops. Then, if a fault is found during the design that was caused by a fault in the requirements, the software developers can backtrack from the design up to the analysis and hence to the requirements and make the necessary corrections there. Then, they move down to the analysis, correct the specification document to reflect the corrections to the requirements, and in turn, correct the design document. Design activities can now resume where they were suspended when the fault was discovered. It is an iterative process as for each new episode, SWD team with move through ‘down the waterfall’ adding and modifying components.
### 3. ###
In my exp, Step-wise refinement is extremely useful to life in general. For my OOP class my goal was to design a quest-like game, I began using step-wise refinement in a sense that I will start with building the world, then characters, then IPC, and then in end, the interactions method. Using this, I was able to move through the project swiftly
### 4. ###
That is correct and pretty straight forward. The requirements analysis is the base of the project and the client can make any modification whenever however, with that in mind requirement analysis should be performed during each episode of the SWD cycle. As far as testing goes, it would be a waste of resources if the team began testing in episode 1. Cycle 1 is when the team should only be focusing on Requirements and design, and nailing everything in place before moving forward to implementation/testing.
### 5. ###
Iterative and incremental development is a discipline for developing systems based on producing deliverables. In incremental development, different parts of the system are developed at various times or rates and are integrated based on their completion. In iterative development, teams plan to revisit parts of the system in order to revise and improve them. User feedback is consulted to modify the targets for successive deliverables. If we were to apply iterative and incremental model to our class project (chess game) it would go something like this: Since chess rule are already set we wouldn’t have to spend much time on requirements, then we’d move to design, implementation, and testing, which would occur in a cyclical fashion for each new component (GUI, then objects, object interaction, game player exp, etc), and as we move through each episode, we will start to focus less on Requirement & Design , and more on Implementation & testing. The main difference between Iterative and incremental dev & spiral software is that in the spiral dev all of the phases are cut horizontally, meaning that each episode of a cycle only focuses on one of the phases. On the other hand, Phases are cut vertically meaning that each episode in the cycle consists of small segments of each of the four phases.
### 6. ###
Yes, indefinitely. Documentation might seem tedious and resource consuming but being organized is one quality every SWE should have. So far in our Project, we’ve done a lousy job of documenting progress; Even though, this is a small project, we need to be inclined to do proper documentation as it keeps us organized
### 7. ###
Of the nine, I find the iterative and incremental model the most appealing to my style of working on software project. Having learned about this process in Chapter 2, I find this model to be useful in one particular aspect. It can be extremely easy to use model when working with different components during project. Each components gets its own ‘episode on cycle’, and in the very end all of the components can be accounted for, in order to finalize the product.
### 8. ###
I found this paper interesting. I’m currently taking Programming Language course in which we go through 7 different languages in one semester. In that class, we’re having to delve into the basics of programming languages like predicate, conditionals, expressions etc for each language because without these basics computing would not have a meaning.